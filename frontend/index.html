<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Teacher Voice Monitoring</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; background:#f7f7fb; }
    .card { background:#fff; padding:1rem 1.25rem; border-radius:12px; box-shadow:0 4px 16px rgba(0,0,0,0.06); max-width:800px; }
    h1 { margin-top:0; }
    button { padding:0.75rem 1rem; border:none; border-radius:10px; background:#2d6cdf; color:#fff; cursor:pointer; }
    button.secondary { background:#6b7280; }
    button:disabled { background:#9ca3af; cursor:not-allowed; }
    .row { display:flex; gap:0.75rem; flex-wrap:wrap; }
    .status { margin-top:0.75rem; padding:0.75rem; background:#eef2ff; border-radius:8px; color:#1e3a8a; }
  .banner { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#fee2e2; color:#991b1b; padding:0.75rem 1rem; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.12); display:none; z-index:9999; }
  .panel { margin-top:1rem; padding:0.75rem; background:#f2f2f7; border-radius:10px; }
  .panel label { display:inline-flex; align-items:center; gap:0.4rem; margin-right:0.75rem; }
  .bar { width:100%; height:10px; background:#e5e7eb; border-radius:6px; overflow:hidden; }
  .barFill { height:100%; background:#10b981; width:0%; transition: width .2s ease; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Teacher Voice Monitoring</h1>

    <h2>Milestone 2: Teacher Enrollment</h2>
    <p>Record the teacher's voice and save the embedding.</p>
    <div class="row" style="margin-bottom:0.5rem;">
      <button id="btnRecord">Record Teacher Voice</button>
      <button id="btnStop" class="secondary" disabled>Stop</button>
      <button id="btnSave" disabled>Save Voice</button>
    </div>
    <div>Last clip: <span id="clipInfo">none</span></div>
    <audio id="player" controls style="margin-top:0.5rem; width:100%;"></audio>

    <h3 style="margin-top:1.25rem;">Quick Verify</h3>
    <div class="row">
      <button id="btnVerify" disabled>Record & Verify</button>
      <label>Threshold <input id="threshold" type="number" value="0.75" step="0.01" min="0" max="1" style="width:6rem;"/></label>
    </div>

    <h2 style="margin-top:1.5rem;">Listening Mode</h2>
    <div class="row">
      <button id="btnStartListening" class="secondary">Start Listening</button>
      <button id="btnStopListening" class="secondary" disabled>Stop Listening</button>
    </div>

    <div class="panel">
      <strong>Settings</strong>
      <div class="row" style="margin-top:0.5rem;">
        <label>Threshold <input id="setThreshold" type="number" value="0.75" step="0.01" min="0" max="1" style="width:6rem;"/></label>
        <label>Smooth Win <input id="setSmooth" type="number" value="4" min="1" step="1" style="width:5rem;"/></label>
        <label>Min Noise Cnt <input id="setMinNoise" type="number" value="3" min="1" step="1" style="width:6rem;"/></label>
        <label>Cooldown(s) <input id="setCooldown" type="number" value="3" min="0" step="0.5" style="width:6rem;"/></label>
        <label>Min RMS <input id="setMinRms" type="number" value="0.02" min="0" step="0.005" style="width:6rem;"/></label>
        <label>Chunk(s) <input id="setChunkSec" type="number" value="2.0" min="0.5" step="0.5" style="width:6rem;"/></label>
        <label>Interval(ms) <input id="setInterval" type="number" value="500" min="100" step="50" style="width:6rem;"/></label>
        <button id="btnApply" class="secondary">Apply</button>
      </div>
    </div>

    <div class="panel">
      <strong>Live Meters</strong>
      <div style="margin-top:0.5rem;">
        <div>Similarity: <span id="simVal">-</span></div>
        <div class="bar"><div id="simBar" class="barFill"></div></div>
      </div>
      <div style="margin-top:0.5rem;">
        <div>RMS: <span id="rmsVal">-</span></div>
        <div class="bar"><div id="rmsBar" class="barFill" style="background:#6366f1;"></div></div>
      </div>
      <div id="procInfo" style="margin-top:0.5rem; font-size:12px; color:#6b7280;"></div>
    </div>

    <div class="status" id="status">Status: Ready</div>
  </div>
  <div class="banner" id="banner">Noise detected, please maintain silence.</div>
  <script>
    const statusEl = document.getElementById('status');
    const btnRecord = document.getElementById('btnRecord');
    const btnStop = document.getElementById('btnStop');
    const btnSave = document.getElementById('btnSave');
    const btnVerify = document.getElementById('btnVerify');
  const player = document.getElementById('player');
    const clipInfo = document.getElementById('clipInfo');
    const thresholdInput = document.getElementById('threshold');
  const btnStartListening = document.getElementById('btnStartListening');
  const btnStopListening = document.getElementById('btnStopListening');
  const banner = document.getElementById('banner');
  const setThreshold = document.getElementById('setThreshold');
  const setSmooth = document.getElementById('setSmooth');
  const setMinNoise = document.getElementById('setMinNoise');
  const setCooldown = document.getElementById('setCooldown');
  const setMinRms = document.getElementById('setMinRms');
  const setChunkSec = document.getElementById('setChunkSec');
  const setIntervalMs = document.getElementById('setInterval');
  const btnApply = document.getElementById('btnApply');
  const simBar = document.getElementById('simBar');
  const rmsBar = document.getElementById('rmsBar');
  const simVal = document.getElementById('simVal');
  const rmsVal = document.getElementById('rmsVal');
  const procInfo = document.getElementById('procInfo');

    let lastBlob = null;

    // Simple in-browser WAV recorder using ScriptProcessorNode
    class WavRecorder {
      constructor() {
        this.audioCtx = null;
        this.source = null;
        this.processor = null;
        this.stream = null;
        this.buffers = [];
        this.sampleRate = 44100;
        this.resolveStop = null;
      }
      async init() {
        this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.sampleRate = this.audioCtx.sampleRate;
        this.source = this.audioCtx.createMediaStreamSource(this.stream);
        this.processor = this.audioCtx.createScriptProcessor(4096, 1, 1);
        this.source.connect(this.processor);
        this.processor.connect(this.audioCtx.destination);
        this.processor.onaudioprocess = (e) => {
          const input = e.inputBuffer.getChannelData(0);
          // Copy the data to avoid using the same underlying buffer
          this.buffers.push(new Float32Array(input));
        };
      }
      async start() {
        if (!this.audioCtx) await this.init();
        this.buffers = [];
      }
      async stop() {
        // Disconnect processor to stop collecting
        try { this.processor.disconnect(); } catch {}
        try { this.source.disconnect(); } catch {}
        try { this.stream.getTracks().forEach(t => t.stop()); } catch {}
        // Flatten buffers
        const length = this.buffers.reduce((a, b) => a + b.length, 0);
        const pcm = new Float32Array(length);
        let offset = 0;
        for (const buf of this.buffers) { pcm.set(buf, offset); offset += buf.length; }
        // Encode WAV as 16-bit PCM
        const wavBlob = this.encodeWAV(pcm, this.sampleRate);
        // Clean up audio context
        try { await this.audioCtx.close(); } catch {}
        this.audioCtx = null;
        return wavBlob;
      }
      encodeWAV(samples, sampleRate) {
        // Convert Float32 [-1,1] to 16-bit PCM
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        const writeString = (offset, str) => { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); };
        const floatTo16 = (out, offset, input) => {
          for (let i = 0; i < input.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, input[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          }
        };
        // RIFF header
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(8, 'WAVE');
        // fmt chunk
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true); // PCM
        view.setUint16(20, 1, true); // format = 1 (PCM)
        view.setUint16(22, 1, true); // channels = 1
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true); // byte rate (sampleRate * blockAlign)
        view.setUint16(32, 2, true); // block align (channels * bytesPerSample)
        view.setUint16(34, 16, true); // bits per sample
        // data chunk
        writeString(36, 'data');
        view.setUint32(40, samples.length * 2, true);
        floatTo16(view, 44, samples);
        return new Blob([view], { type: 'audio/wav' });
      }
    }

    let recorder = null;
    async function ensureRecorder() {
      if (!recorder) recorder = new WavRecorder();
      return recorder;
    }

    function setStatus(msg) {
      statusEl.textContent = 'Status: ' + msg;
    }

    function speak(text) {
      try {
        const u = new SpeechSynthesisUtterance(text);
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    function showBanner(text) {
      banner.textContent = text;
      banner.style.display = 'block';
      setTimeout(() => { banner.style.display = 'none'; }, 1500);
    }

    btnRecord.onclick = async () => {
      const rec = await ensureRecorder();
      setStatus('Recording…');
      btnRecord.disabled = true; btnStop.disabled = false; btnSave.disabled = true; btnVerify.disabled = true;
      await rec.start();
    };
    btnStop.onclick = () => {
      (async () => {
        if (!recorder) return;
        lastBlob = await recorder.stop();
        player.src = URL.createObjectURL(lastBlob);
        clipInfo.textContent = `${(lastBlob.size/1024).toFixed(1)} KB`;
        setStatus('Recorded clip ready');
        btnRecord.disabled = false; btnStop.disabled = true; btnSave.disabled = false; btnVerify.disabled = false;
        recorder = null;
      })();
    };

    async function postBlob(url, blob, extraFormData = {}) {
      const fd = new FormData();
  fd.append('audio', blob, 'clip.wav');
      Object.entries(extraFormData).forEach(([k,v]) => fd.append(k, v));
      const res = await fetch(url, { method: 'POST', body: fd });
      if (!res.ok) throw new Error('Request failed');
      return res.json();
    }

    btnSave.onclick = async () => {
      if (!lastBlob) return setStatus('No clip to save');
      try {
        setStatus('Uploading for enrollment…');
        const data = await postBlob('http://localhost:8000/enroll', lastBlob);
        setStatus(`Enrolled. Embedding dim ${data.embedding_dim}`);
      } catch (e) { setStatus('Enroll failed: ' + e.message); }
    };

    btnVerify.onclick = async () => {
  const rec = await ensureRecorder();
  setStatus('Recording 2s for verification…');
  btnVerify.disabled = true;
  await rec.start();
  await new Promise(r => setTimeout(r, 2000));
  lastBlob = await rec.stop();
  player.src = URL.createObjectURL(lastBlob);
  clipInfo.textContent = `${(lastBlob.size/1024).toFixed(1)} KB`;
  recorder = null;
      try {
        setStatus('Uploading for verification…');
        const data = await postBlob('http://localhost:8000/verify', lastBlob, { threshold: thresholdInput.value });
        setStatus(`Similarity: ${data.similarity.toFixed(3)} | Threshold: ${data.threshold} | is_teacher: ${data.is_teacher}`);
      } catch (e) { setStatus('Verify failed: ' + e.message); }
      finally { btnVerify.disabled = false; }
    };

    // Listening Mode over WebSocket
    let ws = null;
    btnStartListening.onclick = () => {
      if (ws && ws.readyState === WebSocket.OPEN) return;
      const params = new URLSearchParams({
        threshold: setThreshold.value || '0.75',
        smooth_window: setSmooth.value || '4',
        min_noise_count: setMinNoise.value || '3',
        cooldown: setCooldown.value || '3',
  min_rms: setMinRms.value || '0.02',
  chunk_sec: setChunkSec.value || '2.0',
  interval_ms: setIntervalMs.value || '500',
      });
      ws = new WebSocket(`ws://localhost:8000/ws/listen?${params.toString()}`);
      ws.onopen = () => { setStatus('Listening started'); btnStartListening.disabled = true; btnStopListening.disabled = false; };
      ws.onmessage = (evt) => {
        try {
          const data = JSON.parse(evt.data);
          if (data.type === 'result') {
            const sim = (typeof data.similarity === 'number') ? data.similarity.toFixed(3) : 'n/a';
            const msg = `Sim ${sim} / Thr ${data.threshold} | is_teacher: ${data.is_teacher} | rms ${data.rms?.toFixed ? data.rms.toFixed(3) : 'n/a'}`;
            setStatus(msg);
            // meters
            if (typeof data.similarity === 'number') {
              const s = Math.max(0, Math.min(1, data.similarity));
              simBar.style.width = (s * 100).toFixed(0) + '%';
              simVal.textContent = s.toFixed(3);
            }
            if (typeof data.rms === 'number') {
              const denom = Math.max(0.001, (data.min_rms || 0.02) * 2);
              const r = Math.max(0, Math.min(1, data.rms / denom));
              rmsBar.style.width = (r * 100).toFixed(0) + '%';
              rmsVal.textContent = data.rms.toFixed(3);
            }
            if (typeof data.proc_ms === 'number' && typeof data.ts === 'number') {
              const t = new Date(data.ts * 1000).toLocaleTimeString();
              procInfo.textContent = `${t} • proc ${data.proc_ms} ms`;
            }
          } else if (data.type === 'noise_alert') {
            showBanner('Noise detected, please maintain silence.');
            speak('Noise detected, please maintain silence.');
          } else if (data.type === 'error') {
            setStatus('Error: ' + data.message);
          } else if (data.type === 'info') {
            setStatus('Info: ' + data.message);
          }
        } catch (e) { setStatus('WS parse error'); }
      };
      ws.onclose = () => { setStatus('Listening stopped'); btnStartListening.disabled = false; btnStopListening.disabled = true; };
      ws.onerror = () => { setStatus('WebSocket error'); };
    };

    btnStopListening.onclick = async () => {
      try { await fetch('http://localhost:8000/listen/stop', { method: 'POST' }); } catch {}
      try { if (ws) ws.close(); } catch {}
      ws = null;
      setStatus('Listening stopped');
    };

    btnApply.onclick = async () => {
      try {
        const body = {
          threshold: parseFloat(setThreshold.value),
          smooth_window: parseInt(setSmooth.value),
          min_noise_count: parseInt(setMinNoise.value),
          cooldown_sec: parseFloat(setCooldown.value),
          min_rms: parseFloat(setMinRms.value),
          chunk_sec: parseFloat(setChunkSec.value),
          interval_ms: parseInt(setIntervalMs.value),
        };
        await fetch('http://localhost:8000/listen/config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        setStatus('Settings applied');
      } catch (e) { setStatus('Apply failed'); }
    };

    setStatus('Ready');
  </script>
</body>
</html>
