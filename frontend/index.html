<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Teacher Voice Monitoring</title>
  <style>
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 2rem; background:linear-gradient(180deg,#f7f7fb 0,#eef2ff 100%); }
    .card { background:#fff; padding:1.25rem 1.5rem; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,50,0.08); max-width:980px; margin:auto; }
    h1 { margin-top:0; }
    button { padding:0.7rem 1rem; border:none; border-radius:10px; background:linear-gradient(180deg,#3b82f6,#2563eb); color:#fff; cursor:pointer; box-shadow:0 6px 14px rgba(37,99,235,0.25); }
    button.secondary { background:linear-gradient(180deg,#9ca3af,#6b7280); box-shadow:0 6px 14px rgba(107,114,128,0.25); }
    button:disabled { background:#9ca3af; cursor:not-allowed; }
    .row { display:flex; gap:0.75rem; flex-wrap:wrap; }
    .status { margin-top:0.75rem; padding:0.75rem; background:#eef2ff; border-radius:10px; color:#1e3a8a; }
  .banner { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#fee2e2; color:#991b1b; padding:0.75rem 1rem; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.12); display:none; z-index:9999; }
  .panel { margin-top:1rem; padding:0.9rem; background:linear-gradient(180deg,#f8fafc,#f2f2f7); border-radius:12px; border:1px solid #e5e7eb; }
  .panel label { display:inline-flex; align-items:center; gap:0.4rem; margin-right:0.75rem; }
  .bar { width:100%; height:10px; background:#e5e7eb; border-radius:6px; overflow:hidden; }
  .barFill { height:100%; background:#10b981; width:0%; transition: width .2s ease; }
  input[type="text"], input[type="number"] { padding:0.45rem 0.5rem; border:1px solid #e5e7eb; border-radius:8px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Teacher Voice Monitoring</h1>

    <h2> Teacher Enrollment</h2>
    <p>Record the teacher's voice and save the embedding.</p>
    <div class="row" style="margin-bottom:0.5rem;">
      <button id="btnRecord">Record Teacher Voice</button>
      <button id="btnStop" class="secondary" disabled>Stop</button>
      <button id="btnSave" disabled>Save Voice</button>
    </div>
    <div>Last clip: <span id="clipInfo">none</span></div>
    <audio id="player" controls style="margin-top:0.5rem; width:100%;"></audio>

    <h3 style="margin-top:1.25rem;">Quick Verify</h3>
    <div class="row">
      <button id="btnVerify" disabled>Record & Verify</button>
      <label>Threshold <input id="threshold" type="number" value="0.75" step="0.01" min="0" max="1" style="width:6rem;"/></label>
    </div>

    <h2 style="margin-top:1.5rem;">Listening Mode</h2>
    <div class="row">
      <button id="btnStartListening" class="secondary">Start Listening</button>
      <button id="btnStopListening" class="secondary" disabled>Stop Listening</button>
    </div>

    <div class="panel">
      <strong>Settings</strong>
      <div class="row" style="margin-top:0.5rem;">
        <label>Threshold <input id="setThreshold" type="number" value="0.75" step="0.01" min="0" max="1" style="width:6rem;"/></label>
        <label>Smooth Win <input id="setSmooth" type="number" value="4" min="1" step="1" style="width:5rem;"/></label>
        <label>Min Noise Cnt <input id="setMinNoise" type="number" value="3" min="1" step="1" style="width:6rem;"/></label>
        <label>Cooldown(s) <input id="setCooldown" type="number" value="3" min="0" step="0.5" style="width:6rem;"/></label>
  <label>Min RMS <input id="setMinRms" type="number" value="0.02" min="0" step="0.005" style="width:6rem;"/></label>
  <label>Speech RMS <input id="setSpeechRms" type="number" value="0.04" min="0" step="0.005" style="width:6rem;"/></label>
        <label>Chunk(s) <input id="setChunkSec" type="number" value="2.0" min="0.5" step="0.5" style="width:6rem;"/></label>
        <label>Interval(ms) <input id="setInterval" type="number" value="500" min="100" step="50" style="width:6rem;"/></label>
        <button id="btnApply" class="secondary">Apply</button>
      </div>
    </div>

    <div class="panel">
      <strong>Live Meters</strong>
      <div style="margin-top:0.5rem;">
        <div>Similarity: <span id="simVal">-</span></div>
        <div class="bar"><div id="simBar" class="barFill"></div></div>
      </div>
      <div style="margin-top:0.5rem;">
        <div>RMS: <span id="rmsVal">-</span></div>
        <div class="bar"><div id="rmsBar" class="barFill" style="background:#6366f1;"></div></div>
      </div>
      <div id="procInfo" style="margin-top:0.5rem; font-size:12px; color:#6b7280;"></div>
    </div>

    <div class="panel">
      <strong>Rolling Graph</strong>
      <div style="font-size:12px; color:#6b7280; margin: 4px 0;">Similarity over time (last 30s)</div>
  <canvas id="simCanvas" width="760" height="140" style="background:#fff; border-radius:12px; border:1px solid #e5e7eb; width:100%;"></canvas>
    </div>

    <div class="panel">
      <strong>Model Training</strong>
      <div class="row" style="margin-top:0.5rem;">
        <label>Dataset Path <input id="trainData" type="text" style="width:16rem;" value="backend/data/dataset"/></label>
        <label>Steps <input id="trainSteps" type="number" min="100" step="100" value="500" style="width:6rem;"/></label>
        <label>Batch <input id="trainBS" type="number" min="8" step="1" value="32" style="width:5rem;"/></label>
        <button id="btnStartTrain">Start Training</button>
        <button id="btnPollTrain" class="secondary">Poll Status</button>
      </div>
      <div id="trainStatus" class="status" style="margin-top:0.5rem;">Training: idle</div>
    </div>

    <div class="panel">
      <strong>Dataset Collector</strong>
      <div class="row" style="margin-top:0.5rem;">
        <label>Label <input id="dsLabel" type="text" placeholder="teacher or noise or student" style="width:14rem;"/></label>
        <button id="btnDsRecord">Record</button>
        <button id="btnDsStop" class="secondary" disabled>Stop</button>
        <button id="btnDsUpload" disabled>Upload</button>
        <div id="dsInfo" style="align-self:center; color:#4b5563;">Idle</div>
      </div>
    </div>

    <div class="status" id="status">Status: Ready</div>
  </div>
  <div class="banner" id="banner">Noise detected, please maintain silence.</div>
  <script>
    const statusEl = document.getElementById('status');
    const btnRecord = document.getElementById('btnRecord');
    const btnStop = document.getElementById('btnStop');
    const btnSave = document.getElementById('btnSave');
    const btnVerify = document.getElementById('btnVerify');
  const player = document.getElementById('player');
    const clipInfo = document.getElementById('clipInfo');
    const thresholdInput = document.getElementById('threshold');
  const btnStartListening = document.getElementById('btnStartListening');
  const btnStopListening = document.getElementById('btnStopListening');
  const banner = document.getElementById('banner');
  const setThreshold = document.getElementById('setThreshold');
  const setSmooth = document.getElementById('setSmooth');
  const setMinNoise = document.getElementById('setMinNoise');
  const setCooldown = document.getElementById('setCooldown');
  const setMinRms = document.getElementById('setMinRms');
  const setSpeechRms = document.getElementById('setSpeechRms');
  const setChunkSec = document.getElementById('setChunkSec');
  const setIntervalMs = document.getElementById('setInterval');
  const btnApply = document.getElementById('btnApply');
  const simBar = document.getElementById('simBar');
  const rmsBar = document.getElementById('rmsBar');
  const simVal = document.getElementById('simVal');
  const rmsVal = document.getElementById('rmsVal');
  const procInfo = document.getElementById('procInfo');
  const simCanvas = document.getElementById('simCanvas');
  const trainData = document.getElementById('trainData');
  const trainSteps = document.getElementById('trainSteps');
  const trainBS = document.getElementById('trainBS');
  const btnStartTrain = document.getElementById('btnStartTrain');
  const btnPollTrain = document.getElementById('btnPollTrain');
  const trainStatus = document.getElementById('trainStatus');
  const dsLabel = document.getElementById('dsLabel');
  const btnDsRecord = document.getElementById('btnDsRecord');
  const btnDsStop = document.getElementById('btnDsStop');
  const btnDsUpload = document.getElementById('btnDsUpload');
  const dsInfo = document.getElementById('dsInfo');

    let lastBlob = null;

    // Simple in-browser WAV recorder using ScriptProcessorNode
    class WavRecorder {
      constructor() {
        this.audioCtx = null;
        this.source = null;
        this.processor = null;
        this.stream = null;
        this.buffers = [];
        this.sampleRate = 44100;
        this.resolveStop = null;
      }
      async init() {
        this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.sampleRate = this.audioCtx.sampleRate;
        this.source = this.audioCtx.createMediaStreamSource(this.stream);
        this.processor = this.audioCtx.createScriptProcessor(4096, 1, 1);
        this.source.connect(this.processor);
        this.processor.connect(this.audioCtx.destination);
        this.processor.onaudioprocess = (e) => {
          const input = e.inputBuffer.getChannelData(0);
          // Copy the data to avoid using the same underlying buffer
          this.buffers.push(new Float32Array(input));
        };
      }
      async start() {
        if (!this.audioCtx) await this.init();
        this.buffers = [];
      }
      async stop() {
        // Disconnect processor to stop collecting
        try { this.processor.disconnect(); } catch {}
        try { this.source.disconnect(); } catch {}
        try { this.stream.getTracks().forEach(t => t.stop()); } catch {}
        // Flatten buffers
        const length = this.buffers.reduce((a, b) => a + b.length, 0);
        const pcm = new Float32Array(length);
        let offset = 0;
        for (const buf of this.buffers) { pcm.set(buf, offset); offset += buf.length; }
        // Encode WAV as 16-bit PCM
        const wavBlob = this.encodeWAV(pcm, this.sampleRate);
        // Clean up audio context
        try { await this.audioCtx.close(); } catch {}
        this.audioCtx = null;
        return wavBlob;
      }
      encodeWAV(samples, sampleRate) {
        // Convert Float32 [-1,1] to 16-bit PCM
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        const writeString = (offset, str) => { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); };
        const floatTo16 = (out, offset, input) => {
          for (let i = 0; i < input.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, input[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          }
        };
        // RIFF header
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(8, 'WAVE');
        // fmt chunk
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true); // PCM
        view.setUint16(20, 1, true); // format = 1 (PCM)
        view.setUint16(22, 1, true); // channels = 1
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true); // byte rate (sampleRate * blockAlign)
        view.setUint16(32, 2, true); // block align (channels * bytesPerSample)
        view.setUint16(34, 16, true); // bits per sample
        // data chunk
        writeString(36, 'data');
        view.setUint32(40, samples.length * 2, true);
        floatTo16(view, 44, samples);
        return new Blob([view], { type: 'audio/wav' });
      }
    }

    let recorder = null;
    // Rolling graph state
  const simHistory = [];
  const avgWindow = 8; // moving average over recent points
    const maxPoints = 60; // with 500ms updates ~30s
    function redrawGraph() {
      const c = simCanvas.getContext('2d');
      const w = simCanvas.width, h = simCanvas.height;
      c.clearRect(0,0,w,h);
      // axes
      c.strokeStyle = '#e5e7eb'; c.lineWidth = 1;
      for (let i=0;i<=4;i++){ const y = i*(h/4); c.beginPath(); c.moveTo(0,y); c.lineTo(w,y); c.stroke(); }
  // threshold band
  const thr = parseFloat(setThreshold.value || '0.75');
  c.fillStyle = 'rgba(244, 63, 94, 0.08)'; // red-500 at top band above thr
  const thrY = h - Math.max(0, Math.min(1, thr)) * h;
  c.fillRect(0, 0, w, thrY);
  // plot
      if (simHistory.length < 2) return;
      c.strokeStyle = '#0ea5e9'; c.lineWidth = 2; c.beginPath();
      const n = simHistory.length;
      for (let i=0;i<n;i++){
        const x = (i/(n-1))*w;
        const v = Math.max(0, Math.min(1, simHistory[i]));
        const y = h - v*h;
        if (i===0) c.moveTo(x,y); else c.lineTo(x,y);
      }
      c.stroke();
      // moving average
      if (n >= avgWindow) {
        c.strokeStyle = '#22c55e'; c.lineWidth = 2; c.beginPath();
        for (let i=0;i<n;i++){
          const start = Math.max(0, i-avgWindow+1);
          const slice = simHistory.slice(start, i+1);
          const mean = slice.reduce((a,b)=>a+b,0)/slice.length;
          const x = (i/(n-1))*w;
          const y = h - Math.max(0, Math.min(1, mean))*h;
          if (i===0) c.moveTo(x,y); else c.lineTo(x,y);
        }
        c.stroke();
      }
    }
    async function ensureRecorder() {
      if (!recorder) recorder = new WavRecorder();
      return recorder;
    }

    function setStatus(msg) {
      statusEl.textContent = 'Status: ' + msg;
    }

    function speak(text) {
      try {
        const u = new SpeechSynthesisUtterance(text);
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    function showBanner(text) {
      banner.textContent = text;
      banner.style.display = 'block';
      setTimeout(() => { banner.style.display = 'none'; }, 1500);
    }

    btnRecord.onclick = async () => {
      const rec = await ensureRecorder();
      setStatus('Recording…');
      btnRecord.disabled = true; btnStop.disabled = false; btnSave.disabled = true; btnVerify.disabled = true;
      await rec.start();
    };
    btnStop.onclick = () => {
      (async () => {
        if (!recorder) return;
        lastBlob = await recorder.stop();
        player.src = URL.createObjectURL(lastBlob);
        clipInfo.textContent = `${(lastBlob.size/1024).toFixed(1)} KB`;
        setStatus('Recorded clip ready');
        btnRecord.disabled = false; btnStop.disabled = true; btnSave.disabled = false; btnVerify.disabled = false;
        recorder = null;
      })();
    };

    async function postBlob(url, blob, extraFormData = {}) {
      const fd = new FormData();
  fd.append('audio', blob, 'clip.wav');
      Object.entries(extraFormData).forEach(([k,v]) => fd.append(k, v));
      const res = await fetch(url, { method: 'POST', body: fd });
      if (!res.ok) throw new Error('Request failed');
      return res.json();
    }

    btnSave.onclick = async () => {
      if (!lastBlob) return setStatus('No clip to save');
      try {
        setStatus('Uploading for enrollment…');
        const data = await postBlob('http://localhost:8000/enroll', lastBlob);
        setStatus(`Enrolled. Embedding dim ${data.embedding_dim}`);
      } catch (e) { setStatus('Enroll failed: ' + e.message); }
    };

    btnVerify.onclick = async () => {
  const rec = await ensureRecorder();
  setStatus('Recording 2s for verification…');
  btnVerify.disabled = true;
  await rec.start();
  await new Promise(r => setTimeout(r, 2000));
  lastBlob = await rec.stop();
  player.src = URL.createObjectURL(lastBlob);
  clipInfo.textContent = `${(lastBlob.size/1024).toFixed(1)} KB`;
  recorder = null;
      try {
        setStatus('Uploading for verification…');
        const data = await postBlob('http://localhost:8000/verify', lastBlob, { threshold: thresholdInput.value });
        setStatus(`Similarity: ${data.similarity.toFixed(3)} | Threshold: ${data.threshold} | is_teacher: ${data.is_teacher}`);
      } catch (e) { setStatus('Verify failed: ' + e.message); }
      finally { btnVerify.disabled = false; }
    };

    // Listening Mode over WebSocket
    let ws = null;
    btnStartListening.onclick = () => {
      if (ws && ws.readyState === WebSocket.OPEN) return;
      const params = new URLSearchParams({
        threshold: setThreshold.value || '0.75',
        smooth_window: setSmooth.value || '4',
        min_noise_count: setMinNoise.value || '3',
        cooldown: setCooldown.value || '3',
        min_rms: setMinRms.value || '0.02',
        speech_rms: setSpeechRms.value || '0.04',
        chunk_sec: setChunkSec.value || '2.0',
        interval_ms: setIntervalMs.value || '500',
      });
      ws = new WebSocket(`ws://localhost:8000/ws/listen?${params.toString()}`);
      ws.onopen = () => { setStatus('Listening started'); btnStartListening.disabled = true; btnStopListening.disabled = false; };
      ws.onmessage = (evt) => {
        try {
          const data = JSON.parse(evt.data);
          if (data.type === 'result') {
            if (typeof data.similarity === 'number') {
              simHistory.push(Math.max(0, Math.min(1, data.similarity)));
              while (simHistory.length > maxPoints) simHistory.shift();
              redrawGraph();
            }
            const sim = (typeof data.similarity === 'number') ? data.similarity.toFixed(3) : 'n/a';
            const flat = (typeof data.spectral_flatness === 'number') ? data.spectral_flatness.toFixed(3) : 'n/a';
            const msg = `Sim ${sim} / Thr ${data.threshold} | is_teacher: ${data.is_teacher} | rms ${data.rms?.toFixed ? data.rms.toFixed(3) : 'n/a'} | flat ${flat}${data.noise_like ? ' (noise-like)' : ''}`;
            setStatus(msg);
            // meters
            if (typeof data.similarity === 'number') {
              const s = Math.max(0, Math.min(1, data.similarity));
              simBar.style.width = (s * 100).toFixed(0) + '%';
              simVal.textContent = s.toFixed(3);
            }
            if (typeof data.rms === 'number') {
              const denom = Math.max(0.001, (data.min_rms || 0.02) * 2);
              const r = Math.max(0, Math.min(1, data.rms / denom));
              rmsBar.style.width = (r * 100).toFixed(0) + '%';
              rmsVal.textContent = data.rms.toFixed(3);
            }
            if (typeof data.proc_ms === 'number' && typeof data.ts === 'number') {
              const t = new Date(data.ts * 1000).toLocaleTimeString();
              procInfo.textContent = `${t} • proc ${data.proc_ms} ms`;
            }
          } else if (data.type === 'noise_alert') {
            showBanner('Noise detected, please maintain silence.');
            speak('Noise detected, please maintain silence.');
          } else if (data.type === 'error') {
            setStatus('Error: ' + data.message);
          } else if (data.type === 'info') {
            setStatus('Info: ' + data.message);
          }
        } catch (e) { setStatus('WS parse error'); }
      };
      ws.onclose = () => { setStatus('Listening stopped'); btnStartListening.disabled = false; btnStopListening.disabled = true; };
      ws.onerror = () => { setStatus('WebSocket error'); };
    };

    btnStopListening.onclick = async () => {
      try { await fetch('http://localhost:8000/listen/stop', { method: 'POST' }); } catch {}
      try { if (ws) ws.close(); } catch {}
      ws = null;
      setStatus('Listening stopped');
    };

    btnApply.onclick = async () => {
      try {
        const body = {
          threshold: parseFloat(setThreshold.value),
          smooth_window: parseInt(setSmooth.value),
          min_noise_count: parseInt(setMinNoise.value),
          cooldown_sec: parseFloat(setCooldown.value),
          min_rms: parseFloat(setMinRms.value),
          chunk_sec: parseFloat(setChunkSec.value),
          interval_ms: parseInt(setIntervalMs.value),
          speech_rms: parseFloat(setSpeechRms.value),
        };
        await fetch('http://localhost:8000/listen/config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        setStatus('Settings applied');
      } catch (e) { setStatus('Apply failed'); }
    };

    // Dataset collector
    let dsBlob = null;
    btnDsRecord.onclick = async () => {
      const rec = await ensureRecorder();
      dsInfo.textContent = 'Recording…';
      btnDsRecord.disabled = true; btnDsStop.disabled = false; btnDsUpload.disabled = true;
      await rec.start();
    };
    btnDsStop.onclick = async () => {
      if (!recorder) return;
      dsBlob = await recorder.stop();
      recorder = null;
      dsInfo.textContent = `${(dsBlob.size/1024).toFixed(1)} KB ready`;
      btnDsRecord.disabled = false; btnDsStop.disabled = true; btnDsUpload.disabled = false;
    };
    btnDsUpload.onclick = async () => {
      if (!dsBlob) return; if (!dsLabel.value.trim()) { dsInfo.textContent = 'Enter a label'; return; }
      try {
        const fd = new FormData();
        fd.append('label', dsLabel.value.trim());
        fd.append('audio', dsBlob, 'clip.wav');
        const res = await fetch('http://localhost:8000/dataset/upload', { method:'POST', body: fd });
        const j = await res.json();
        if (j.ok) { dsInfo.textContent = 'Uploaded: ' + j.path; dsBlob = null; btnDsUpload.disabled = true; }
        else { dsInfo.textContent = 'Upload failed: ' + (j.error || ''); }
      } catch (e) { dsInfo.textContent = 'Upload error'; }
    };

    // Training controls
    btnStartTrain.onclick = async () => {
      try {
        const body = {
          data: trainData.value,
          steps: parseInt(trainSteps.value, 10),
          bs: parseInt(trainBS.value, 10)
        };
        const res = await fetch('http://localhost:8000/model/train', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        const j = await res.json();
        trainStatus.textContent = 'Training: ' + (j.ok ? 'started' : ('not started: ' + (j.message || '')));
      } catch (e) {
        trainStatus.textContent = 'Training start failed';
      }
    };

    btnPollTrain.onclick = async () => {
      try {
        const res = await fetch('http://localhost:8000/model/train/status');
        const j = await res.json();
        trainStatus.textContent = `Training: ${j.running ? 'running' : 'idle'} | step ${j.step}/${j.steps} | loss ${j.loss ?? '-'}${j.error ? ' | error: '+j.error : ''}`;
        if (!j.running && j.out_path) {
          const st = await (await fetch('http://localhost:8000/model/status')).json();
          if (st.model_present) {
            trainStatus.textContent += ' | model ready, re-enroll recommended';
          }
        }
      } catch (e) {
        trainStatus.textContent = 'Training status failed';
      }
    };

    setStatus('Ready');
  </script>
</body>
</html>
